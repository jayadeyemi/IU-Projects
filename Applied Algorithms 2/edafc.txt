import numpy as np

def heapify(arr, N, i, sniperPoint):
    largest = i # Initialize largest as root
    l = 2 * i + 1 # left = 2*i + 1
    r = 2 * i + 2 # right = 2*i + 2

    # See if left child of root exists and is greater than root
    if l < N and  np.linalg.norm(np.array(arr[largest])) < np.linalg.norm(np.array(arr[l])):
        largest = l

    # See if right child of root exists and is greater than root
    if r < N and np.linalg.norm(np.array(arr[largest])) < np.linalg.norm(np.array(arr[r])):
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i] # swap

        # Heapify the root.
        heapify(arr, N, largest, sniperPoint)

def helpRyan(points, sniperPoint):
    N = len(points)
    
    # Build a minheap.
    for i in range(N//2 - 1, -1, -1):
        heapify(points, N, i, sniperPoint)

    # One by one extract elements
    for i in range(N-1, 0, -1):
        points[i], points[0] = points[0], points[i] # swap
        heapify(points, i, 0, sniperPoint)

    return points


def jacksMachine(objects,query):
    n = len(objects)
    if query < 1 or query > n:
        return -1
    
    def quicksort(arr, low, high, k):

        def split_recursive_sort(arr, low, high):
            pivot = arr[high]  # Choose the last element
            i = low - 1  # Index of smaller element
            for j in range(low, high):
                if arr[j] <= pivot:
                    i += 1
                    arr[i], arr[j] = arr[j], arr[i]  # Swap elements
            arr[i + 1], arr[high] = arr[high], arr[i + 1]  # Swap pivot with element at i+1
            return i + 1
        
        if low < high:  
            pi = split_recursive_sort(arr, low, high) # split the list and find the kth item in the appriate split
            if pi == k:
                return arr[pi]  # if the index of the last item in the sublist matches, return the item
            elif pi < k:
                return quicksort(arr, pi + 1, high, k)  # else if the index of the last item in the sublist is less than the kth item, quicksort the second half
            else:
                return quicksort(arr, low, pi - 1, k)   # else if the index of the last item in the sublist is greater than the kth item, quicksort the second half
        else:
            return arr[low]  # else the last item in the main list is the k-th element
        
    return quicksort(objects, 0, n - 1, n - query)  # perform quicksort

def subarrayWithMinimumCost(harvestArray):
    def heapify(arr, n, i):
        smallest = i
        left = 2 * i + 1
        right = 2 * i + 2

        if left < n and arr[left] > arr[smallest]:
            smallest = left

        if right < n and arr[right] > arr[smallest]:
            smallest = right

        if smallest != i:
            arr[i], arr[smallest] = arr[smallest], arr[i]
            heapify(arr, n, smallest)
    
    firstitem = harvestArray[0]
    harvestArray.pop(0)
    
    length = len(harvestArray)

    # Build a min heap.
    for i in range(length // 2 - 1, -1, -1):
        heapify(harvestArray, length, i)

    # Extract elements from the heap in decreasing order.
    for i in range(length - 1, 0, -1):
        harvestArray[0], harvestArray[i] = harvestArray[i], harvestArray[0]
        heapify(harvestArray, i, 0)
    
    return firstitem + min(sum(harvestArray[:2]), sum(harvestArray[1:3]), sum([harvestArray[0], harvestArray[2]]))

def maxEarnings(start_time, end_time, profit):

    def moded_mergeSort(events): 
        if len(events) <= 1:
            return events
        mid = len(events) // 2

        def merge(left, right):
            result = []
            i = j = 0
            while i < len(left) and j < len(right):
                if left[i][0] <= right[j][0]:
                    result.append(left[i])
                    i += 1
                else:
                    result.append(right[j])
                    j += 1
            result += left[i:]
            result += right[j:]
            return result
        
        left = moded_mergeSort(events[:mid])
        right = moded_mergeSort(events[mid:])
        return merge(left, right)
    
    # Combine start time, end time, and profit into tuples
    events = list(zip(start_time, end_time, profit))
    n = len(events)
    events = moded_mergeSort(events)


    # Initialize an array to store maximum earnings at each event
    dp_profit = [-1] * n
    
    for i in range(n):
        dp_profit[i] = events[i][2]
        for j in range(i):
            if events[j][1] <= events[i][0]:
                dp_profit[i] = max(dp_profit[i], dp_profit[j] + events[i][2])



    # Return the maximum profit among all events
    return max(dp_profit)
def minimum_cost(blossom_costs):
    n = len(blossom_costs)
    memoization_table = [-1] * n  # Table to store results, initialized to -1

    def helper(cost, index):
        if index >= n:  # Base case
            return 0
        if memoization_table[index] != -1:
            return memoization_table[index]

        min_cost = float('inf')
        max_index = min(2 * index + 2, n)  # Maximum possible index
        for i in range(index + 1, max_index + 1):
            min_cost = min(min_cost, cost[index] + helper(cost, i))  # Minimum cost for remaining flowers

        memoization_table[index] = min_cost
        return min_cost

    return helper(blossom_costs, 0)


# Example usage:
blossom_costs = [2, 4, 6, 3, 8]
print(minimum_cost(blossom_costs))

def maxCoins(nums):
    # Add 1 to the beginning and end of the nums array
    nums = [1] + nums + [1]
    n = len(nums)
    
    # Create a DP table to store the maximum coins for each subproblem
    dp = [[0] * n for _ in range(n)]
    
    # Iterate over all possible balloon ranges
    for length in range(2, n):
        for left in range(0, n - length):
            right = left + length
            # Try each balloon as the last one to burst in the range
            for i in range(left + 1, right):
                dp[left][right] = max(dp[left][right], 
                                      nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])
    
    # Return the maximum coins for the entire range
    return dp[0][n - 1]



import heapq

class Huffman:
    def __init__(self):
        self.huffman_codes = {}
        self.source_string = ""

    def set_source_string(self, src_str):
        self.source_string = src_str

    def generate_codes(self):
        frequency = {}
        for char in self.source_string:
            frequency[char] = frequency.get(char, 0) + 1

        heap = [[weight, [char, ""]] for char, weight in frequency.items()]
        heapq.heapify(heap)  # Use heapq.heapify for proper heap creation

        while len(heap) > 1:
            left = heapq.heappop(heap)
            right = heapq.heappop(heap)

            for pair in left[1:]:
                pair[1] = '0' + pair[1]
            for pair in right[1:]:
                pair[1] = '1' + pair[1]

            heapq.heappush(heap, [left[0] + right[0]] + left[1:] + right[1:])

        self.huffman_codes = dict(sorted(heap[0][1:], key=lambda p: (len(p[-1]), p)))
        return heap  # Return the generated Huffman tree

    def encode_message(self, message_to_encode):
        encoded_msg = ""
        for char in message_to_encode:
            encoded_msg += self.huffman_codes[char]
        return encoded_msg

    def decode_message(self, encoded_msg):
        decoded_msg = ""
        current_code = ""

        for bit in encoded_msg:
            current_code += bit
            for char, code in self.huffman_codes.items():
                if code == current_code:
                    decoded_msg += char
                    current_code = ""
                    break

        return decoded_msg
class Node:
   def __init__(self, stored_value, left_child=None, right_child=None):
       self.stored_value = stored_value
       self.left_child = left_child
       self.right_child = right_child

class Wavelet_Tree:
   def __init__(self, input_array):
       self.root_node = self.construct_wavelet_tree(input_array, 0, 9)

   def construct_wavelet_tree(self, input_array, lower_bound, upper_bound):
       if lower_bound == upper_bound:
           return Node('X' * len(input_array))

       midpoint = (lower_bound + upper_bound) // 2
       partitioning_bits = []
       for element_index in range(len(input_array)):
           if input_array[element_index] > midpoint:
               partitioning_bits.append(1)
           else:
               partitioning_bits.append(0)
       partitioning_string = "".join(map(str, partitioning_bits))
       current_node = Node(partitioning_string)

       left_subtree_array = []
       right_subtree_array = []
       for element in input_array:
           if element <= midpoint:
               left_subtree_array.append(element)
           else:
               right_subtree_array.append(element)

       current_node.left_child = self.construct_wavelet_tree(left_subtree_array, lower_bound, midpoint)
       current_node.right_child = self.construct_wavelet_tree(right_subtree_array, midpoint + 1, upper_bound)

       return current_node

   def get_wavelet_level_order(self):
       output_list = []
       if not self.root_node:
           return output_list

       node_queue = []
       node_queue.append(self.root_node)
       while node_queue:
           level_strings = []
           for _ in range(len(node_queue)):
               current_node = node_queue.pop(0)
               level_strings.append(current_node.stored_value)
               if current_node.left_child:
                   node_queue.append(current_node.left_child)
               if current_node.right_child:
                   node_queue.append(current_node.right_child)
           output_list.append(level_strings)

       return output_list

   def rank(self, target_character, position_index):
       return self.recursive_rank_helper(self.root_node, 0, 9, target_character, position_index)

   def recursive_rank_helper(self, current_node, lower_bound, upper_bound, target_character, position_index):
       if lower_bound == upper_bound:
           return position_index

       if not current_node or position_index == 0:
           return 0

       midpoint = (lower_bound + upper_bound) // 2
       count_of_zeros = 0
       substring = current_node.stored_value[:position_index]
       for character in substring:
           if character == '0':
               count_of_zeros += 1
       count_of_ones = position_index - count_of_zeros

       if target_character <= midpoint:
           return self.recursive_rank_helper(current_node.left_child, lower_bound, midpoint, target_character, count_of_zeros)
       else:
           return self.recursive_rank_helper(current_node.right_child, midpoint + 1, upper_bound, target_character, count_of_ones)
